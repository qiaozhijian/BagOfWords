#include "DBoW3/DBoW3.h"
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/features2d/features2d.hpp>
#include <iostream>
#include <vector>
#include <string>
#include "util.h"
#include "lsd_detect.h"

using namespace cv;
using namespace std;

/***************************************************
 * 本节演示了如何根据前面训练的字典计算相似性评分
 * ************************************************/
#define TEST_INDEXES_NUM 2
int seq_interval = 100000;
int main(int argc, char **argv) {
    // read the images and database
    cout << "reading images... " << endl;
    vector<Mat> images;
    string path = "/media/qzj/Document/grow/research/slamDataSet/sweepRobot/round3/";
    int trainIdx[TEST_INDEXES_NUM] = { 1, 2 };

    //载入所有图片的路径
    vector<string> vImgPaths;
    vector<uint32_t > vImgIndexes;
    for ( int i=0; i<TEST_INDEXES_NUM; i++ )
    {
        string seq = to_string(trainIdx[i]);
        while (seq.size()<2)
            seq="0"+seq;
        string img_path = path + seq + "/left/";
        vector<string> vstrImageLeft;
        //img_path="./data";
        LoadImages(img_path, vstrImageLeft);
        for(int j=0;j<vstrImageLeft.size();j++)
            vImgIndexes.push_back(j + seq_interval * trainIdx[i]);
        vImgPaths.insert(vImgPaths.end(),vstrImageLeft.begin(),vstrImageLeft.end());
    }

    //载入图片
    for(auto path:vImgPaths)
        images.push_back(imread(path));

    // NOTE: in this case we are comparing images with a vocabulary generated by themselves, this may lead to overfit.
    // detect ORB features
    cout << "detecting ORB features ... " << endl;
    Ptr< Feature2D > detector = ORB::create();
    vector<Mat> pdescs;
    vector<Mat> ldescs;
    for ( Mat& image:images )
    {
        vector<KeyPoint> keypoints;
        Mat pdesc, ldesc;
        vector<line_descriptor::KeyLine> keylines;
        detector->detectAndCompute( image, Mat(), keypoints, pdesc );
        pdescs.push_back( pdesc );

        ExtractLineSegment(image, keylines, ldesc);
        ldescs.push_back( ldesc);
    }

    ofstream f;
    f.open("./result_dbow_pl.txt");
    f << fixed;

    cout << "reading database" << endl;
    DBoW3::Vocabulary vocab_pt("./robot_vocab_pt.yml.gz");
    DBoW3::Vocabulary vocab_line("./robot_vocab_line.yml.gz");
    if (vocab_pt.empty() || vocab_line.empty()) {
        cerr << "Vocabulary does not exist." << endl;
        return 1;
    }

    int candi_num = 200;
    if(true)
    {
        cout << "comparing images with images " << endl;
        vector<vector<std::pair<uint32_t, double>>> loop_id(images.size());
        vector<DBoW3::BowVector> ptBowVector;
        vector<DBoW3::BowVector> lineBowVector;
        for (int i = 0; i < images.size(); i++) {
            DBoW3::BowVector v1_pt,v1_line;
            vocab_pt.transform(pdescs[i], v1_pt);
            vocab_line.transform(ldescs[i], v1_line);
            ptBowVector.push_back(v1_pt);
            lineBowVector.push_back(v1_line);
        }

        cout << "build BowVector database." << endl;
        for (int i = 0; i < images.size(); i++) {
            DBoW3::BowVector v1_pt=ptBowVector[i],v1_line=lineBowVector[i];
            cout << "build BowVector "<< i << endl;
            for (int j = 0; j < images.size(); j++) {
                //因为是个对称矩阵
                if(j < i)
                {
                    std::pair<uint32_t, double> ij(j, loop_id[j][i].second);
                    loop_id[i].push_back(ij);
                    continue;
                }
                DBoW3::BowVector v2_pt=ptBowVector[j],v2_line=lineBowVector[j];
                double score_pt = vocab_pt.score(v1_pt, v2_pt);
                double score_line = vocab_line.score(v1_line, v2_line);
                double score = (score_pt * pdescs[i].rows + score_line * ldescs[i].rows) / (pdescs[i].rows + ldescs[i].rows);
                loop_id[i].push_back(std::pair<uint32_t, double>(j, score));
            }
        }

        cout << "sort scores " << endl;
        for (int i = 0; i < loop_id.size(); i++)
        {
            std::sort(loop_id[i].begin(), loop_id[i].end(), scoreTopMax);
            f<<vImgIndexes[i]<<" ";
            //最接近的总是本身，应该去掉
            for(int j=1;j<candi_num+1;j++)
            {
                f<<vImgIndexes[loop_id[i][j].first];
                if(j<candi_num)
                    f<<" ";
            }
            if(i<loop_id.size()-1)
                f<<endl;
        }
        f.close();
        cout << "done." << endl;
    }

    // or with database
    if(false)
    {
        cout << "comparing images with database " << endl;
        DBoW3::Database db(vocab_pt, false, 0);
        for (int i = 0; i < pdescs.size(); i++)
            db.add(pdescs[i]);
        cout << "database info: " << db << endl;
        for (int i = 0; i < pdescs.size(); i++) {
            DBoW3::QueryResults ret;
            db.query(pdescs[i], ret, candi_num);      // max result=4
            f<<vImgIndexes[i]<<" ";
            for(int j=1;j<ret.size();j++)
            {
                f<<vImgIndexes[ret[j].Id];
                if(j<ret.size()-1)
                    f<<" ";
            }
            f<<endl;
            //cout << "searching for image " << i << " returns " << ret << endl;
        }
        f.close();
        cout << "done." << endl;
    }
}
